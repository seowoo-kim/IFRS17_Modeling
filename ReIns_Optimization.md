```sql

--###업무요건
--보험신회계제도 ifrs17 업무상 재보험 평균 출재율 취합과정은 세가지 분류가 존재함.
--분류1 : 원수보험(원수보험포트폴리오, 원수보험동일유형그룹코드, 원수보험goc유형그룹코드)과 재보험(재보험포트폴리오, 재보험동일유형그룹코드, 재보험goc유형그룹코드) 기준을 동시적용한 출재단위 취합.
--분류2 : 전사단위(원수보험재보험 구분없이 회계년월과 회계단계만구분)의 취합.
--분류3 : 재보험(재보험포트폴리오, 재보험동일유형그룹코드, 재보험goc유형그룹코드)내의 취합.


--기존 작업은 세가지 분류각각의 세번 full scan으로 각기 다른 유형분류코드로 insert가 되었음.
--소스테이블의 크기가 최소 5~6000만, 최대 20억건정도의 데이터로, 대용량 작업이 오라클엑사라도 부담스러워 다음의 문제가 있음.
--문제 1. 동일 작업이 실패할때도 많음(때때로 서버프리징으로 해당 작업 멈춤 이후 롤백됨).
--문제 2. 다른 작업에 영향이 큼(cpu 점유율이 높아 db가용성저하, undo segment, temptablespace부족으로 다른 작업들 모두 비정상종료, 비정상종료시 백그라운드 프로세스에 의한 정상화에 시간걸려 3시간정도 작업불가).
--문제 3. 작업시간이 길어 "계리모델(hpc환경에서 애플리케이션으로 연산)cash flow 산출->db취합->재무결산 회계무브먼트" 진행 상 업무 flow가 매끄럽지 못함. 작업시간종료를 서로 맞추기 어려워서 로스 타임으로 작업이 지연됨.



--##최적화 이전 3가지 작업으로 구성되어 있음. 아래는 세 쿼리 원본.
--가장 중요한 회계무브먼트인 1130(최종결산단계)을 기준으로 최적화 테스트 진행함. 
--기존 쿼리가 윈도우 함수를 유지할 수밖에 없었던 이유 :
--1. 단순 분류기준 3가지 외에도 ACCT_PYMT_COD(사고지급유형코드)별로 별도의 처리가 필요하여 대상 레코드를 따로 처리하는 윈도우 프레임 파티셔닝이 필요했고, 
--2. IFRS17결산이 분기누적결산임에 따라 파티셔닝된 여러 회계기준년월의 무브먼트를 다시 읽어 재취합하며 작업이 필요했기 때문임.

SET TIMING ON;


--###세분화단위 1번
--INSERT INTO CF_SIMU.RSUR_AVG_CEDRT

INSERT INTO FMS.RSUR_AVG_CEDRT_TMP	--이하 INSERT대상 테이블은, 테스트 부담을 줄이기 위해서 pk등 삭제한 테이블에서 임시로 취합 확인해봄.
  SELECT /*+FULL(A) PARALLEL(A 4) */
      A.IFRS_ACTS_YYMM, A.VALU_YYMM, '1' AS AVG_RTO_SECD, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD
    , A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD, A.DRCTBZ_GOC_TYP_COD, TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') AS PROG_YYMM
    , '0' AS TMP_PK, NVL(A.GRP_CED_RKPREM / DECODE(A.GRP_RN_RKPREM, 0, NULL, A.GRP_RN_RKPREM), 0) AS AVG_CEDRT
  FROM
  (
    SELECT /*+FULL(A) PARALLEL(A 4) */ A.*
          , SUM(CASE WHEN A.ACCT_PYMT_COD ='BASE' THEN A.RN_RKPREM ELSE 0 END ) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS GRP_RN_RKPREM
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM ELSE 0 END ) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS GRP_CED_RKPREM
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS IDX
    FROM CF_SIMU.RSUR_CED_RKPREM A
    WHERE A.IFRS_ACTS_YYMM ='201810' AND A.IFRS_WRK_SECD ='E' AND A.MVMT_SECD ='1130'
  ) A
  WHERE A.IDX = 1 AND PRFT_COMS_XC_GRP_COD <> 'BASE'
;
COMMIT;

--###전사단위 2
--INSERT INTO CF_SIMU.RSUR_AVG_CEDRT

INSERT INTO FMS.RSUR_AVG_CEDRT_TMP
  SELECT /*+FULL(A) PARALLEL(A 4) */
      A.IFRS_ACTS_YYMM, A.VALU_YYMM, '2' AS AVG_RTO_SECD, 'NA' AS PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD
    , 'NA' AS RSUR_PF_SECD, 'NA' AS RSUR_SAME_GRP_TYP_COD, 'NA' AS RSUR_GOC_TYP_COD, 'NA' AS DRCTBZ_PF_SECD, 'NA' AS DRCTBZ_SAME_GRP_TYP_COD, 'NA' AS DRCTBZ_GOC_TYP_COD
    , TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') AS PROG_YYMM
    , '0' AS TMP_PK, NVL(A.GRP_CED_RKPREM / DECODE(A.GRP_RN_RKPREM, 0, NULL, A.GRP_RN_RKPREM), 0) AS AVG_CEDRT
  FROM
  (
    SELECT /*+FULL(A) PARALLEL(A 4) */ A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD
          , SUM(CASE WHEN A.ACCT_PYMT_COD ='BASE' THEN A.RN_RKPREM END) AS GRP_RN_RKPREM
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM END) AS GRP_CED_RKPREM
    FROM CF_SIMU.RSUR_CED_RKPREM A
    WHERE A.IFRS_ACTS_YYMM ='201810' AND A.IFRS_WRK_SECD ='E' AND A.MVMT_SECD ='1130'
    GROUP BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD
  ) A
;
COMMIT;

--###재보만 3번
--INSERT INTO CF_SIMU.RSUR_AVG_CEDRT
INSERT INTO FMS.RSUR_AVG_CEDRT_TMP
  SELECT /*+FULL(A) PARALLEL(A 4) */
      A.IFRS_ACTS_YYMM, A.VALU_YYMM, '3' AS AVG_RTO_SECD, 'NA' AS PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD
    , A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, 'NA' AS DRCTBZ_PF_SECD, 'NA' AS DRCTBZ_SAME_GRP_TYP_COD, 'NA' AS DRCTBZ_GOC_TYP_COD
    , TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') AS PROG_YYMM
    , '0' AS TMP_PK, NVL(A.GRP_CED_RKPREM / DECODE(A.GRP_RN_RKPREM, 0, NULL, A.GRP_RN_RKPREM), 0) AS AVG_CEDRT
  FROM
  (
    SELECT /*+FULL(A) PARALLEL(A 4) */ A.*
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM ELSE 0 END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD) AS GRP_RN_RKPREM
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM ELSE 0 END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD) AS GRP_CED_RKPREM
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD) AS IDX
    FROM CF_SIMU.RSUR_CED_RKPREM A
    WHERE A.IFRS_ACTS_YYMM ='201810' AND A.IFRS_WRK_SECD ='E' AND A.MVMT_SECD ='1130'
  ) A
  WHERE A.IDX = 1 AND PRFT_COMS_XC_GRP_COD <> 'BASE'
;
COMMIT;

--총 세번의 쿼리 수행으로 작업 종료함.
--평균 작업완수시간 1시간



--###최적화 1차시도
--세쿼리 각각에서 window function을 쓰면서 소팅이 있었지만 원쿼리로 합침. 결과적으로 WINDOW SORT OPERATION을 2번으로 줄임. 한번의 FULL SCAN에 두번의 정렬과정으로 세가지 기준을 만족하도록함.
--그러나 한번의 정렬과정으로 불가한 이유는 1번, 2번, 3번 쿼리의 모든 WINDOW FUNCTION을 한번에 정렬할 수 있는 기준을 세우는 것이 불가능하기 때문임.
--성과 : 기존보다 FULL SCAN횟수 줄어서 명시적인 시간이 감소함
--단점 : 정렬기준이 3기준 중 가장 많은 1번 출재단위기준보다 배열이 큼(정렬기준통합이 불가능하기에 두번정렬해서 들고있게됨), 다만 각3번의 TMEP SAPCE사용량 합보다 적음.
--결론 : 시간이 명시적으로 줄어들고 자원을 좀더 적게 먹는 작업의 경우가 늘었지만, 아직 만족스럽지 못함. 원쿼리의 작업이 실패하는 경우는 없었으나 아직 다른 DB작업을 병행하기엔 무리가 있음.

INSERT /*+ENABLE_PARALLEL_DML APPEND PARALLEL(Z 4) */ INTO CF_SIMU.RSUR_AVG_CEDRT Z
  SELECT /*+FULL(A) PARALLEL(A 4) */ 
      A.IFRS_ACTS_YYMM, A.VALU_YYMM
    , CASE WHEN A.IDX = 1 THEN '1' 
           WHEN A.IDX_2 = 2 THEN '2'
           WHEN A.IDX_3 = 3 THEN '3' END AS AVG_RTO_SECD
    , CASE WHEN A.IDX = 1 THEN A.PRFT_COMS_XC_GRP_COD ELSE 'NA' END                 AS PRFT_COMS_XC_GRP_COD
    , A.IFRS_WRK_SECD, A.MVMT_SECD 
    , CASE WHEN A.IDX_2 = 2 THEN 'NA' ELSE A.RSUR_PF_SECD END                       AS RSUR_PF_SECD
    , CASE WHEN A.IDX_2 = 2 THEN 'NA' ELSE A.RSUR_SAME_GRP_TYP_COD END              AS RSUR_SAME_GRP_TYP_COD
    , CASE WHEN A.IDX_2 = 2 THEN 'NA' ELSE A.RSUR_GOC_TYP_COD END                   AS RSUR_GOC_TYP_COD
    , CASE WHEN A.IDX = 1 THEN A.DRCTBZ_PF_SECD ELSE 'NA' END                       AS DRCTBZ_PF_SECD
    , CASE WHEN A.IDX = 1 THEN A.DRCTBZ_SAME_GRP_TYP_COD ELSE 'NA' END              AS DRCTBZ_SAME_GRP_TYP_COD
    , CASE WHEN A.IDX = 1 THEN A.DRCTBZ_GOC_TYP_COD ELSE 'NA' END                   AS DRCTBZ_GOC_TYP_COD
    , TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') AS PROG_YYMM
    , '0'                                                                           AS TMP_PK
    , CASE WHEN A.IDX = 1 THEN NVL(A.GRP_CED_RKPREM_1 / DECODE(A.GRP_RN_RKPREM_1, 0, NULL, A.GRP_RN_RKPREM_1), 0)
           WHEN A.IDX_2 = 2 THEN NVL(A.GRP_CED_RKPREM_2 / DECODE(A.GRP_RN_RKPREM_2, 0, NULL, A.GRP_RN_RKPREM_2), 0)
           WHEN A.IDX_3 = 3 THEN NVL(A.GRP_CED_RKPREM_3 / DECODE(A.GRP_CED_RKPREM_2, 0, NULL, A.GRP_CED_RKPREM_2), 0)
           END                                                                      AS AVG_CEDRT
  FROM
  (
    SELECT /*+FULL(A) PARALLEL(A 4) */ A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD
          , SUM(CASE WHEN A.ACCT_PYMT_COD ='BASE' THEN A.RN_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS GRP_RN_RKPREM_1
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS GRP_CED_RKPREM_1 
          , SUM(CASE WHEN A.ACCT_PYMT_COD ='BASE' THEN A.RN_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD)   AS GRP_RN_RKPREM_2
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD) AS GRP_CED_RKPREM_2
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD) AS GRP_CED_RKPREM_3  
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS IDX
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD) AS IDX_2
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD) AS IDX_3
    FROM CF_SIMU.RSUR_CED_RKPREM A
    WHERE A.IFRS_ACTS_YYMM ='201810' AND A.IFRS_WRK_SECD ='E' AND A.MVMT_SECD ='1130'
  ) A
  WHERE (A.IDX = 1 AND A.PRFT_COMS_XC_GRP_COD <> 'BASE') OR (A.IDX_2 = 2 AND A.PRFT_COMS_XC_GRP_COD <>'BASE') OR (A.IDX_3 = 3 AND A.PRFT_COMS_XC_GRP_COD <>'BASE')
;
COMMIT;



--###최적화 2차시도
--취합대상 레코드에 비해 결과집합(result set)이 굉장히 작다는 것에 착안하여 MATERIALIZE 내재힌트를 이용할 수 있도록 GROUPING SET을 이용함.
--결과집합이 작을 수 있는 이유는 재보험 도메인의 특성때문이며, 구체적으로는 다음과 같음. 
--1. IFRS17 분기결산기준 하에서 동일유형그룹코드는 분기단위로 산출됨, EX) 2018_1Q, 2018_2Q - 따라서 1년에 최대 4개의 동질성이 있는 cohort(집단)만 발생함.
--2. 출재단위는 재보험사단위와 크게 다르지 않는데, 코리안리와 해외재보험사까지 다해도 기업수 자체가 적기 때문에 계약유형이 수십개에 불과함.
--3. GOC(group of contract)도 IFRS17기준하 이익, 손실, 손실가능성 집단 3가지 구분을 원칙으로 함.
--위의 이유로 가장 세분화된 기준으로 묶었을때조차 레코드수가 ifrs17도입예상 시점 기준으로 1000개 정도 이므로(향후 10년최대 가정시에도 10000개가 안될 것으로 예상하여 문제는 없어 보임),
--1000개를 메모리에 올려두고 메모리상에서 각 필요단위로 다시 그룹핑하여 INSERT함(inmemory grouping & sorting).

--성과 : 시간 획기적으로 줄어 빠를땐 1분미만 걸림. 순수히 읽는시간이 전체 작업시간의 대부분으로 잡힌듯함. 
--단점 : 특정시점에서 in-memory 불가한경우 성능이 급격히 안좋아질 수 있음. 적절한 파티셔닝과, 해당 시점의 회계업무요건 재확인하여 조치가 필요할 것임. 
--다만 계약의 유지가 10년 안팎이므로 최악의 경우에도 문제가 안될 가능성이 높고, 관련내용은 관계자에게 공유함. 현재까지 극단적인케이스에도 문제는 없었음.
--결론 : 단일 FULLSCAN에 윈도우함수처럼 배열을 많이먹는 SORTING방식을 취하지도, 여러기준을 동시에 잡지도 않아 메모리를 넘치지도 않기에 인메모리로 가능함. 상정한 극단적인케이스에도 문제는 없었음.

--또다른 테스트 시점으로 마감년월 201804로도 해보고, 누적결산 시점인 201805의 1130 무브먼트 기준으로도 정합성 확인함.


--SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
--EXPLAIN PLAN FOR

INSERT /*+ENABLE_PARALLEL_DML APPEND PARALLEL(Z 16) */ INTO CF_SIMU.RSUR_AVG_CEDRT Z
SELECT /*+PARALLEL(A 16) */ A.IFRS_ACTS_YYMM, A.VALU_YYMM
	, CASE WHEN A.PRFT_COMS_XC_GRP_COD IS NOT NULL THEN '1'
		   WHEN A.RSUR_PF_SECD IS NULL AND A.DRCTBZ_PF_SECD IS NULL THEN '2'
		   ELSE '3' END			AS AVG_RTO_SECD
	, CASE WHEN A.PRFT_COMS_XC_GRP_COD IS NOT NULL THEN A.PRFT_COMS_XC_GRP_COD ELSE 'NA' END                 			        AS PRFT_COMS_XC_GRP_COD
	, A.IFRS_WRK_SECD
	, A.MVMT_SECD
    , CASE WHEN A.RSUR_PF_SECD IS NULL THEN 'NA' ELSE A.RSUR_PF_SECD END            		 					 	 	        AS RSUR_PF_SECD
    , CASE WHEN A.RSUR_SAME_GRP_TYP_COD IS NULL THEN 'NA' ELSE A.RSUR_SAME_GRP_TYP_COD END   					 	 	        AS RSUR_SAME_GRP_TYP_COD
    , CASE WHEN A.RSUR_GOC_TYP_COD IS NULL THEN 'NA' ELSE A.RSUR_GOC_TYP_COD END    		 					 	 	        AS RSUR_GOC_TYP_COD
    , CASE WHEN A.DRCTBZ_PF_SECD IS NULL THEN 'NA' ELSE A.DRCTBZ_PF_SECD END     								 	 	        AS DRCTBZ_PF_SECD
    , CASE WHEN A.DRCTBZ_SAME_GRP_TYP_COD IS NULL THEN 'NA' ELSE A.DRCTBZ_SAME_GRP_TYP_COD END      			 	 	        AS DRCTBZ_SAME_GRP_TYP_COD
    , CASE WHEN A.DRCTBZ_GOC_TYP_COD IS NULL THEN 'NA' ELSE A.DRCTBZ_GOC_TYP_COD END                			 	 	        AS DRCTBZ_GOC_TYP_COD
	, CASE WHEN A.MVMT_SECD ='1000' THEN A.IFRS_ACTS_YYMM ELSE TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') END 	        AS PROG_YYMM
    , '0' AS TMP_PK
    , CASE WHEN A.PRFT_COMS_XC_GRP_COD IS NULL AND A.RSUR_PF_SECD IS NOT NULL THEN NVL(A.GRP_CED_RKPREM/DECODE(A.GRP_1_P, 0, NULL, A.GRP_1_P), 0)
    	   WHEN A.PRFT_COMS_XC_GRP_COD IS NULL AND A.RSUR_PF_SECD IS NULL THEN NVL(A.GRP_CED_RKPREM/DECODE(A.GRP_RN_RKPREM, 0, NULL, A.GRP_RN_RKPREM), 0)
    	   WHEN A.PRFT_COMS_XC_GRP_COD IS NOT NULL THEN NVL(A.GRP_CED_RKPREM/ DECODE(A.GRP_1_P, 0, NULL, A.GRP_1_P), 0) END     AS AVG_RTO
FROM 
    (SELECT A.*
        , CASE WHEN A.PRFT_COMS_XC_GRP_COD IS NOT NULL THEN MAX(A.GRP_RN_RKPREM) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD)
               WHEN A.PRFT_COMS_XC_GRP_COD IS NULL AND A.RSUR_PF_SECD IS NOT NULL THEN LAST_VALUE(GRP_CED_RKPREM) OVER (ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD, A.PRFT_COMS_XC_GRP_COD) END AS GRP_1_P
    FROM 
        (SELECT /*+ FULL(A) PARALLEL(A 16) */ '201905' AS IFRS_ACTS_YYMM, VALU_YYMM    --목표로 하고 있는 회계년월을 어플리케이션에서 입력받음. 
            , PRFT_COMS_XC_GRP_COD, IFRS_WRK_SECD, MVMT_SECD
            , RSUR_PF_SECD, RSUR_SAME_GRP_TYP_COD, RSUR_GOC_TYP_COD
            , DRCTBZ_GOC_TYP_COD, DRCTBZ_PF_SECD, DRCTBZ_SAME_GRP_TYP_COD
            , SUM(CASE WHEN ACCT_PYMT_COD = 'BASE' THEN A.RN_RKPREM END) 	AS GRP_RN_RKPREM
            , SUM(CASE WHEN ACCT_PYMT_COD <> 'BASE' THEN A.CED_RKPREM END) 	AS GRP_CED_RKPREM
        FROM CF_SIMU.RSUR_CED_RKPREM A

        --WHERE IFRS_ACTS_YYMM ='201904' AND IFRS_WRK_SECD ='E' AND MVMT_SECD ='1000'    --** test case 1. 분기의 시작(분기별로 1, 4, 7, 10월) 회계대상 최초인식대상으로 맞춰봄.
        WHERE (IFRS_ACTS_YYMM, MVMT_SECD) IN (('201904', '1000'), ('201905', '1000')) AND IFRS_WRK_SECD ='E'     
        --** test case 2. 위의 multi in 조건으로 4,5월 동시입력하여 5월로 출력함. ifrs17이 분기누적결산이므로 5월 1130에서는 4월데이터도 같이 읽어야함. 
        --만약 산출 년월이 6월이었다면 4,5월 데이터까지 누적해서 IN ('201904', '1000'), ('201905', '1000'), ('201906', '1000'))
        GROUP BY GROUPING SETS ((VALU_YYMM, IFRS_WRK_SECD, MVMT_SECD), (VALU_YYMM, IFRS_WRK_SECD, MVMT_SECD, DRCTBZ_GOC_TYP_COD, DRCTBZ_PF_SECD, DRCTBZ_SAME_GRP_TYP_COD)
                                , (VALU_YYMM, IFRS_WRK_SECD, MVMT_SECD, RSUR_PF_SECD, RSUR_SAME_GRP_TYP_COD, RSUR_GOC_TYP_COD), (VALU_YYMM, PRFT_COMS_XC_GRP_COD, IFRS_WRK_SECD, MVMT_SECD, RSUR_PF_SECD, RSUR_SAME_GRP_TYP_COD, RSUR_GOC_TYP_COD, DRCTBZ_GOC_TYP_COD, DRCTBZ_PF_SECD, DRCTBZ_SAME_GRP_TYP_COD))
        HAVING NVL(RSUR_SAME_GRP_TYP_COD, 0) <> 'BASE') A
    ) A
WHERE (A.RSUR_PF_SECD IS NULL AND A.DRCTBZ_PF_SECD IS NULL) OR (A.RSUR_PF_SECD IS NOT NULL)
;         

COMMIT;




--###query 바꾼 이후 최소한의 정합성 확인 검증용쿼리
--단순히 모든 값의 일치함로 확인함.
SELECT COUNT(A.IFRS_ACTS_YYMM) FROM FMS.RSUR_AVG_CEDRT_TMP A, CF_SIMU.RSUR_AVG_CEDRT B
WHERE 1=1
AND A.IFRS_ACTS_YYMM = B.IFRS_ACTS_YYMM
AND A.VALU_YYMM = B.VALU_YYMM
AND A.AVG_RTO_SECD = B.AVG_RTO_SECD
AND A.PRFT_COMS_XC_GRP_COD = B.PRFT_COMS_XC_GRP_COD
AND A.IFRS_WRK_SECD = B.IFRS_WRK_SECD
AND A.MVMT_SECD = B.MVMT_SECD
AND A.RSUR_PF_SECD = B.RSUR_PF_SECD
AND A.RSUR_SAME_GRP_TYP_COD = B.RSUR_SAME_GRP_TYP_COD
AND A.RSUR_GOC_TYP_COD = B.RSUR_GOC_TYP_COD
AND A.DRCTBZ_PF_SECD = B.DRCTBZ_PF_SECD
AND A.DRCTBZ_SAME_GRP_TYP_COD = B.DRCTBZ_SAME_GRP_TYP_COD
AND A.DRCTBZ_GOC_TYP_COD = B.DRCTBZ_GOC_TYP_COD
AND A.PROG_YYMM = B.PROG_YYMM
AND A.TMP_PK = B.TMP_PK
AND A.AVG_RTO = B.AVG_RTO;


```
