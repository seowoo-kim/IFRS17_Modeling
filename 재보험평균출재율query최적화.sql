--보험신회계제도 ifrs17에 적용할 재보험 평균 출재율 취합과정은 세가지 분류가 존재함.
--1.원수보험(원수보험포트폴리오, 원수보험동일유형그룹코드, 원수보험goc유형그룹코드)과 재보험(재보험포트폴리오, 재보험동일유형그룹코드, 재보험goc유형그룹코드) 기준을 동시적용한 출재단위 취합,
--2.전사단위(원수보험재보험 구분없이 회계년월과 회계단계만구분)의 취합, 3.재보험(재보험포트폴리오, 재보험동일유형그룹코드, 재보험goc유형그룹코드)내의 취합, 

--기존 작업은 세가지 분류각각의 세번 full scan으로 각기 다른 유형분류코드로 insert가 되었음
--소스테이블의 크기가 최소 5~6000만, 최대 20억건정도의 데이터로, full scan이 오라클엑사라도 부담스러워 동일작업이 실패할때도 많음(때때로 서버프리징으로 해당 작업 멈춤 이후 롤백됨. 다른작업의 속도에도 영향).
--또 다른 작업에 영향을 주고(cpu 점유율이 높아 db가용성저하, undo segment, temptablespace부족으로 다른 작업들 모두 비정상종료, 비정상종료시 백그라운드 프로세스에 의한 정상화에 시간걸려 3시간정도 작업불가),
--작업시간이 오래걸려 계리모델(hpc이용, 애플리케이션을 통한 연산후 결과값 산출) cash flow 산출->db취합->재무결산 회계무브먼트 진행에서 업무 flow가 매끄럽지 못함. 작업시간종료를 서로 맞추기 어려워서 작업이 지연됨.

--가장 중요한 회계무브먼트인 1130(최종결산단계)을 기준으로 최적화 진행함. 
--아래는 기존 쿼리, 기존 쿼리가 윈도우 함수를 유지할 수밖에 없었던 이유로는 단순 분류기준 3가지 외에도 ACCT_PYMT_COD(사고지급유형코드)별로
--취합해줘야하는 대상 레코드에 차이가 있어 윈도우 프레임 파티셔닝이 필요했고, IFRS17결산이 분기누적결산임에 따라 파티셔닝된 여러 회계기준년월의 무브먼트를 다시 읽어 재취합하며 작업이 필요했기 때문임.

--**************************************************** 최적화 전 3가지 작업확인

SET TIMING ON;


-----세분화단위 1번
--INSERT INTO CF_SIMU.RSUR_AVG_CEDRT
INSERT INTO FMS.RSUR_AVG_CEDRT_TMP	--pk등 삭제한 테이블에서 임시로 취합확인해봄.
  SELECT /*+FULL(A) PARALLEL(A 4) */
      A.IFRS_ACTS_YYMM, A.VALU_YYMM, '1' AS AVG_RTO_SECD, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD
    , A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD, A.DRCTBZ_GOC_TYP_COD, TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') AS PROG_YYMM
    , '0' AS TMP_PK, NVL(A.GRP_CED_RKPREM / DECODE(A.GRP_RN_RKPREM, 0, NULL, A.GRP_RN_RKPREM), 0) AS AVG_CEDRT
  FROM
  (
    SELECT /*+FULL(A) PARALLEL(A 4) */ A.*
          , SUM(CASE WHEN A.ACCT_PYMT_COD ='BASE' THEN A.RN_RKPREM ELSE 0 END ) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS GRP_RN_RKPREM
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM ELSE 0 END ) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS GRP_CED_RKPREM
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS IDX
    FROM CF_SIMU.RSUR_CED_RKPREM A
    WHERE A.IFRS_ACTS_YYMM ='201810' AND A.IFRS_WRK_SECD ='E' AND A.MVMT_SECD ='1130'
  ) A
  WHERE A.IDX = 1 AND PRFT_COMS_XC_GRP_COD <> 'BASE'
;
COMMIT;

----전사단위 2
--INSERT INTO CF_SIMU.RSUR_AVG_CEDRT
INSERT INTO FMS.RSUR_AVG_CEDRT_TMP
  SELECT /*+FULL(A) PARALLEL(A 4) */
      A.IFRS_ACTS_YYMM, A.VALU_YYMM, '2' AS AVG_RTO_SECD, 'NA' AS PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD
    , 'NA' AS RSUR_PF_SECD, 'NA' AS RSUR_SAME_GRP_TYP_COD, 'NA' AS RSUR_GOC_TYP_COD, 'NA' AS DRCTBZ_PF_SECD, 'NA' AS DRCTBZ_SAME_GRP_TYP_COD, 'NA' AS DRCTBZ_GOC_TYP_COD
    , TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') AS PROG_YYMM
    , '0' AS TMP_PK, NVL(A.GRP_CED_RKPREM / DECODE(A.GRP_RN_RKPREM, 0, NULL, A.GRP_RN_RKPREM), 0) AS AVG_CEDRT
  FROM
  (
    SELECT /*+FULL(A) PARALLEL(A 4) */ A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD
          , SUM(CASE WHEN A.ACCT_PYMT_COD ='BASE' THEN A.RN_RKPREM END) AS GRP_RN_RKPREM
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM END) AS GRP_CED_RKPREM
    FROM CF_SIMU.RSUR_CED_RKPREM A
    WHERE A.IFRS_ACTS_YYMM ='201810' AND A.IFRS_WRK_SECD ='E' AND A.MVMT_SECD ='1130'
    GROUP BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD
  ) A
;
COMMIT;

-------재보만 3번
--INSERT INTO CF_SIMU.RSUR_AVG_CEDRT
INSERT INTO FMS.RSUR_AVG_CEDRT_TMP
  SELECT /*+FULL(A) PARALLEL(A 4) */
      A.IFRS_ACTS_YYMM, A.VALU_YYMM, '3' AS AVG_RTO_SECD, 'NA' AS PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD
    , A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, 'NA' AS DRCTBZ_PF_SECD, 'NA' AS DRCTBZ_SAME_GRP_TYP_COD, 'NA' AS DRCTBZ_GOC_TYP_COD
    , TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') AS PROG_YYMM
    , '0' AS TMP_PK, NVL(A.GRP_CED_RKPREM / DECODE(A.GRP_RN_RKPREM, 0, NULL, A.GRP_RN_RKPREM), 0) AS AVG_CEDRT
  FROM
  (
    SELECT /*+FULL(A) PARALLEL(A 4) */ A.*
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM ELSE 0 END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD) AS GRP_RN_RKPREM
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM ELSE 0 END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD) AS GRP_CED_RKPREM
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD) AS IDX
    FROM CF_SIMU.RSUR_CED_RKPREM A
    WHERE A.IFRS_ACTS_YYMM ='201810' AND A.IFRS_WRK_SECD ='E' AND A.MVMT_SECD ='1130'
  ) A
  WHERE A.IDX = 1 AND PRFT_COMS_XC_GRP_COD <> 'BASE'
;
COMMIT;

--총 세번의 쿼리 수행

--**************************************************** 최적화 1차시도
--WINDOW SORT OPERATION을 2번으로 줄임. 한번의 FULL SCAN에서 두번의 정렬과정으로 세가지 기준을 만족하도록함.
--한번의 정렬과정으로 불가한 이유는 1번, 2번, 3번 쿼리의 모든 WINDOW FUNCTION을 한번에 정렬할 수 있는 기준 수립이 불가능하기 때문임.
--성과 : 기존보다 FULL SCAN횟수 줄어서 명시적인 시간이 감소함,
--단점 : 정렬기준이 3기준 중 가장 많은 1번 출재단위기준보다 배열이 큼(정렬기준통합이 불가능하기에 두번정렬해서 들고있게됨), 다만 각3번의 TMEP SAPCE사용량 합보다 훨씬적음
--시간이 명시적으로 줄어들고 자원을 좀더 적게 먹는 경우가 많지만 아직 만족스럽지 못함. 작업이 실패하는 경우는 없으나 아직 다른 DB작업을 병행하기엔 무리가 있음.

INSERT /*+ENABLE_PARALLEL_DML APPEND PARALLEL(Z 4) */ INTO CF_SIMU.RSUR_AVG_CEDRT Z
  SELECT /*+FULL(A) PARALLEL(A 4) */ 
      A.IFRS_ACTS_YYMM, A.VALU_YYMM
    , CASE WHEN A.IDX = 1 THEN '1' 
           WHEN A.IDX_2 = 2 THEN '2'
           WHEN A.IDX_3 = 3 THEN '3' END AS AVG_RTO_SECD
    , CASE WHEN A.IDX = 1 THEN A.PRFT_COMS_XC_GRP_COD ELSE 'NA' END                 AS PRFT_COMS_XC_GRP_COD
    , A.IFRS_WRK_SECD, A.MVMT_SECD 
    , CASE WHEN A.IDX_2 = 2 THEN 'NA' ELSE A.RSUR_PF_SECD END                       AS RSUR_PF_SECD
    , CASE WHEN A.IDX_2 = 2 THEN 'NA' ELSE A.RSUR_SAME_GRP_TYP_COD END              AS RSUR_SAME_GRP_TYP_COD
    , CASE WHEN A.IDX_2 = 2 THEN 'NA' ELSE A.RSUR_GOC_TYP_COD END                   AS RSUR_GOC_TYP_COD
    , CASE WHEN A.IDX = 1 THEN A.DRCTBZ_PF_SECD ELSE 'NA' END                       AS DRCTBZ_PF_SECD
    , CASE WHEN A.IDX = 1 THEN A.DRCTBZ_SAME_GRP_TYP_COD ELSE 'NA' END              AS DRCTBZ_SAME_GRP_TYP_COD
    , CASE WHEN A.IDX = 1 THEN A.DRCTBZ_GOC_TYP_COD ELSE 'NA' END                   AS DRCTBZ_GOC_TYP_COD
    , TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') AS PROG_YYMM
    , '0'                                                                           AS TMP_PK
    , CASE WHEN A.IDX = 1 THEN NVL(A.GRP_CED_RKPREM_1 / DECODE(A.GRP_RN_RKPREM_1, 0, NULL, A.GRP_RN_RKPREM_1), 0)
           WHEN A.IDX_2 = 2 THEN NVL(A.GRP_CED_RKPREM_2 / DECODE(A.GRP_RN_RKPREM_2, 0, NULL, A.GRP_RN_RKPREM_2), 0)
           WHEN A.IDX_3 = 3 THEN NVL(A.GRP_CED_RKPREM_3 / DECODE(A.GRP_CED_RKPREM_2, 0, NULL, A.GRP_CED_RKPREM_2), 0)
           END                                                                      AS AVG_CEDRT
  FROM
  (
    SELECT /*+FULL(A) PARALLEL(A 4) */ A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD
          , SUM(CASE WHEN A.ACCT_PYMT_COD ='BASE' THEN A.RN_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS GRP_RN_RKPREM_1
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS GRP_CED_RKPREM_1 
          , SUM(CASE WHEN A.ACCT_PYMT_COD ='BASE' THEN A.RN_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD)   AS GRP_RN_RKPREM_2
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD) AS GRP_CED_RKPREM_2
          , SUM(CASE WHEN A.ACCT_PYMT_COD <>'BASE' THEN A.CED_RKPREM END) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD) AS GRP_CED_RKPREM_3  
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.PRFT_COMS_XC_GRP_COD, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD) AS IDX
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD) AS IDX_2
          , ROW_NUMBER() OVER(PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD
                              ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.RSUR_PF_SECD, A.RSUR_SAME_GRP_TYP_COD, A.RSUR_GOC_TYP_COD) AS IDX_3
    FROM CF_SIMU.RSUR_CED_RKPREM A
    WHERE A.IFRS_ACTS_YYMM ='201810' AND A.IFRS_WRK_SECD ='E' AND A.MVMT_SECD ='1130'
  ) A
  WHERE (A.IDX = 1 AND A.PRFT_COMS_XC_GRP_COD <> 'BASE') OR (A.IDX_2 = 2 AND A.PRFT_COMS_XC_GRP_COD <>'BASE') OR (A.IDX_3 = 3 AND A.PRFT_COMS_XC_GRP_COD <>'BASE')
;
COMMIT;

--**************************************************** 최적화 2차시도
--결과집합이 굉장히 적다는 것에 착안하여(IFRS17 분기결산기준 하에서 동일유형그룹코드는 분기단위로 산출됨, EX) 2018_1Q, 2018_2Q,
--출재단위는 국내 출재한 코리안리, 스코어리 등의 재보험사 수 자체가 적기 때문에 계약유형이 몇십개에 불과함, GOC도 IFRS17기준하 이익, 손실, 손실가능성 집단 3가지 구분하에 가짓수가 적음)
--MATERIALIZE 내재힌트를 이용할 수 있도록 GROUPING SET을 이용함.
--가장 세분화된 기준으로 묶었을때조차 레코드수가 100개 정도이므로 (향후 10년최대 가정시에도 1000개가 안될 것으로 예상함),
--1000개를 메모리에 올려두고 메모리상에서 각 필요단위로 재그룹핑하여 INSERT함
--시간 획기적으로 줄어 빠를땐 1분미만 걸림. 순수히 읽는시간이 작업시간의 대부분으로 잡힌듯함. 
--단일 FULLSCAN에 윈도우함수처럼 배열을 많이먹는 SORTING방식을 취하지도, 여러기준을 동시에 잡지도 않아 메모리를 넘치지도 않기에 인메모리로 가능.

--201804로도 해보고, 누적결산 시점인 201805의 1130 무브먼트 기준으로도 정합성 확인함.

--SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
--EXPLAIN PLAN FOR

INSERT /*+ENABLE_PARALLEL_DML APPEND PARALLEL(Z 16) */ INTO CF_SIMU.RSUR_AVG_CEDRT Z
SELECT /*+PARALLEL(A 16) */ A.IFRS_ACTS_YYMM, A.VALU_YYMM
	, CASE WHEN A.PRFT_COMS_XC_GRP_COD IS NOT NULL THEN '1'
		   WHEN A.RSUR_PF_SECD IS NULL AND A.DRCTBZ_PF_SECD IS NULL THEN '2'
		   ELSE '3' END			AS AVG_RTO_SECD
	, CASE WHEN A.PRFT_COMS_XC_GRP_COD IS NOT NULL THEN A.PRFT_COMS_XC_GRP_COD ELSE 'NA' END                 			        AS PRFT_COMS_XC_GRP_COD
	, A.IFRS_WRK_SECD
	, A.MVMT_SECD
    , CASE WHEN A.RSUR_PF_SECD IS NULL THEN 'NA' ELSE A.RSUR_PF_SECD END            		 					 	 	        AS RSUR_PF_SECD
    , CASE WHEN A.RSUR_SAME_GRP_TYP_COD IS NULL THEN 'NA' ELSE A.RSUR_SAME_GRP_TYP_COD END   					 	 	        AS RSUR_SAME_GRP_TYP_COD
    , CASE WHEN A.RSUR_GOC_TYP_COD IS NULL THEN 'NA' ELSE A.RSUR_GOC_TYP_COD END    		 					 	 	        AS RSUR_GOC_TYP_COD
    , CASE WHEN A.DRCTBZ_PF_SECD IS NULL THEN 'NA' ELSE A.DRCTBZ_PF_SECD END     								 	 	        AS DRCTBZ_PF_SECD
    , CASE WHEN A.DRCTBZ_SAME_GRP_TYP_COD IS NULL THEN 'NA' ELSE A.DRCTBZ_SAME_GRP_TYP_COD END      			 	 	        AS DRCTBZ_SAME_GRP_TYP_COD
    , CASE WHEN A.DRCTBZ_GOC_TYP_COD IS NULL THEN 'NA' ELSE A.DRCTBZ_GOC_TYP_COD END                			 	 	        AS DRCTBZ_GOC_TYP_COD
	, CASE WHEN A.MVMT_SECD ='1000' THEN A.IFRS_ACTS_YYMM ELSE TO_CHAR(ADD_MONTHS(A.VALU_YYMM||'01',1),'YYYYMM') END 	        AS PROG_YYMM
    , '0' AS TMP_PK
    , CASE WHEN A.PRFT_COMS_XC_GRP_COD IS NULL AND A.RSUR_PF_SECD IS NOT NULL THEN NVL(A.GRP_CED_RKPREM/DECODE(A.GRP_1_P, 0, NULL, A.GRP_1_P), 0)
    	   WHEN A.PRFT_COMS_XC_GRP_COD IS NULL AND A.RSUR_PF_SECD IS NULL THEN NVL(A.GRP_CED_RKPREM/DECODE(A.GRP_RN_RKPREM, 0, NULL, A.GRP_RN_RKPREM), 0)
    	   WHEN A.PRFT_COMS_XC_GRP_COD IS NOT NULL THEN NVL(A.GRP_CED_RKPREM/ DECODE(A.GRP_1_P, 0, NULL, A.GRP_1_P), 0) END     AS AVG_RTO
FROM 
    (SELECT A.*
        , CASE WHEN A.PRFT_COMS_XC_GRP_COD IS NOT NULL THEN MAX(A.GRP_RN_RKPREM) OVER (PARTITION BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD)
               WHEN A.PRFT_COMS_XC_GRP_COD IS NULL AND A.RSUR_PF_SECD IS NOT NULL THEN LAST_VALUE(GRP_CED_RKPREM) OVER (ORDER BY A.IFRS_ACTS_YYMM, A.VALU_YYMM, A.IFRS_WRK_SECD, A.MVMT_SECD, A.DRCTBZ_GOC_TYP_COD, A.DRCTBZ_PF_SECD, A.DRCTBZ_SAME_GRP_TYP_COD, A.PRFT_COMS_XC_GRP_COD) END AS GRP_1_P
    FROM 
        (SELECT /*+ FULL(A) PARALLEL(A 16) */ '201905' AS IFRS_ACTS_YYMM, VALU_YYMM                  --목표로 하고 있는 회계년월 입력이 필요함. 신계약에서 월별로 모든 구분으로 존재하는것이 아니라서 MAX로 잡을 수 없음
            , PRFT_COMS_XC_GRP_COD, IFRS_WRK_SECD, MVMT_SECD
            , RSUR_PF_SECD, RSUR_SAME_GRP_TYP_COD, RSUR_GOC_TYP_COD
            , DRCTBZ_GOC_TYP_COD, DRCTBZ_PF_SECD, DRCTBZ_SAME_GRP_TYP_COD
            , SUM(CASE WHEN ACCT_PYMT_COD = 'BASE' THEN A.RN_RKPREM END) 	AS GRP_RN_RKPREM
            , SUM(CASE WHEN ACCT_PYMT_COD <> 'BASE' THEN A.CED_RKPREM END) 	AS GRP_CED_RKPREM
--        FROM FMS.RSUR_CED_RKPREM_T A	--임시TABLE
        FROM CF_SIMU.RSUR_CED_RKPREM A
        --WHERE IFRS_ACTS_YYMM ='201904' AND IFRS_WRK_SECD ='E' AND MVMT_SECD ='1000'                                                      --4월만 입력하여 4월로 출력
        WHERE (IFRS_ACTS_YYMM, MVMT_SECD) IN (('201904', '1000'), ('201905', '1000')) AND IFRS_WRK_SECD ='E'                                --4,5월 동시입력하여 5월로 출력, ifrs17이 분기누적결산이므로 5월 1130에서는 4월데이터도 같이 읽어야함. 6월이라면 4,5월 데이터도.
--        WHERE (IFRS_ACTS_YYMM, MVMT_SECD) IN (('201905', '1130')) AND IFRS_WRK_SECD ='E'                              --5월 1130 값 확인
        GROUP BY GROUPING SETS ((VALU_YYMM, IFRS_WRK_SECD, MVMT_SECD), (VALU_YYMM, IFRS_WRK_SECD, MVMT_SECD, DRCTBZ_GOC_TYP_COD, DRCTBZ_PF_SECD, DRCTBZ_SAME_GRP_TYP_COD)
                                , (VALU_YYMM, IFRS_WRK_SECD, MVMT_SECD, RSUR_PF_SECD, RSUR_SAME_GRP_TYP_COD, RSUR_GOC_TYP_COD), (VALU_YYMM, PRFT_COMS_XC_GRP_COD, IFRS_WRK_SECD, MVMT_SECD, RSUR_PF_SECD, RSUR_SAME_GRP_TYP_COD, RSUR_GOC_TYP_COD, DRCTBZ_GOC_TYP_COD, DRCTBZ_PF_SECD, DRCTBZ_SAME_GRP_TYP_COD))
        HAVING NVL(RSUR_SAME_GRP_TYP_COD, 0) <> 'BASE') A
    ) A
WHERE (A.RSUR_PF_SECD IS NULL AND A.DRCTBZ_PF_SECD IS NULL) OR (A.RSUR_PF_SECD IS NOT NULL)
;         

COMMIT;




--query 바꾼 이후 최소한의 정합성 확인 검증용쿼리
SELECT COUNT(A.IFRS_ACTS_YYMM) FROM FMS.RSUR_AVG_CEDRT_TMP A, CF_SIMU.RSUR_AVG_CEDRT B
WHERE 1=1
AND A.IFRS_ACTS_YYMM = B.IFRS_ACTS_YYMM
AND A.VALU_YYMM = B.VALU_YYMM
AND A.AVG_RTO_SECD = B.AVG_RTO_SECD
AND A.PRFT_COMS_XC_GRP_COD = B.PRFT_COMS_XC_GRP_COD
AND A.IFRS_WRK_SECD = B.IFRS_WRK_SECD
AND A.MVMT_SECD = B.MVMT_SECD
AND A.RSUR_PF_SECD = B.RSUR_PF_SECD
AND A.RSUR_SAME_GRP_TYP_COD = B.RSUR_SAME_GRP_TYP_COD
AND A.RSUR_GOC_TYP_COD = B.RSUR_GOC_TYP_COD
AND A.DRCTBZ_PF_SECD = B.DRCTBZ_PF_SECD
AND A.DRCTBZ_SAME_GRP_TYP_COD = B.DRCTBZ_SAME_GRP_TYP_COD
AND A.DRCTBZ_GOC_TYP_COD = B.DRCTBZ_GOC_TYP_COD
AND A.PROG_YYMM = B.PROG_YYMM
AND A.TMP_PK = B.TMP_PK
AND A.AVG_RTO = B.AVG_RTO;


